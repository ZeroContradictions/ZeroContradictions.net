<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024 May 17, 10:36 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Unix/Linux Commands, Syntax, And Notes</title>
<meta name="author" content="Zero Contradictions" />
<meta name="description" content="This webpage features a summary of commands and information from the Unix Programming Environment, and other commands and information compiled from other sources." />
<meta name="generator" content="Org Mode" />
<style>pre.src-bash:before {content: 'bash'; }</style>
<!-- Google tag (gtag.js) --> <script async src="https://www.googletagmanager.com/gtag/js?id=G-S8XK8JC00G"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-S8XK8JC00G'); </script>
<link rel="stylesheet" type="text/css" href="/style.css">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="/"> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">Unix/Linux Commands, Syntax, And Notes</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#UNIX-syntax">1. UNIX / Linux Metacharacters And Syntax</a>
<ul>
<li><a href="#unix-control-characters">1.1. UNIX Control Characters</a></li>
</ul>
</li>
<li><a href="#UNIX-commands-to-remember">2. UNIX Commands To Remember</a></li>
<li><a href="#command-description-syntax">3. Command Description Syntax</a></li>
<li><a href="#fundamental-UNIX-commands">4. Fundamental Unix Commands To Remember</a></li>
<li><a href="#file-system-root-directories">5. Root Directories In The File System</a>
<ul>
<li><a href="#first-char-of-ls-l">5.1. The First Character of ls -l Output</a></li>
</ul>
</li>
<li><a href="#man-manual-sections">6. Man Manual Sections</a></li>
<li><a href="#file-system-and-secruity-commands">7. File Systems And Security Commands</a></li>
<li><a href="#filters-pipes-and-redirection">8. Filters, Pipes, And Redirection</a></li>
<li><a href="#shell-scripting">9. Shell Scripting</a></li>
<li><a href="#fedora-yum-RPM-commands">10. Fedora Yum RPM Commands</a></li>
<li><a href="#linux-commands-to-be-installed">11. Special Linux Commands To Be Installed</a>
<ul>
<li><a href="#improved-UNIX-utilities">11.1. List Of Improved UNIX Utilities Vs Common Standards</a></li>
</ul>
</li>
<li><a href="#common-linux-commands-not-listed">12. Summary Of Common Linux Commands Not Listed Above</a></li>
<li><a href="#UNIX-notes">13. UNIX Notes</a></li>
</ul>
</div>
</nav>

<div id="outline-container-UNIX-syntax" class="outline-2">
<h2 id="UNIX-syntax"><span class="section-number-2">1.</span> UNIX / Linux Metacharacters And Syntax</h2>
<div class="outline-text-2" id="text-UNIX-syntax">
<ul class="org-ul">
<li>* : match any string of characters</li>
<li>[&#x2026;] : match any string inside the brackets</li>
<li>? : match any single character</li>
<li>newline : most common command terminator</li>
<li>; : command terminator to separate input into two commands; commands are run in sequence</li>
<li>&amp; : start the command and keep it running in the background, then take further commands immediately; also a command terminator</li>
<li>| : redirect output from the left side into the input of the right side; programs on both sides of the pipe run simultaneously, allowing for interactive functions</li>
<li>&amp;&amp; : run first command; if successful then run second command</li>
<li>|| : run first command; if unsuccessful then run second command</li>
<li>&gt;file-name : store output in the following file, not the terminal
<ul class="org-ul">
<li>echo hello &gt;file-name is equivalent to &gt;file-name echo hello</li>
</ul></li>
<li>&gt;&gt;file-name : store the output at the end of the file</li>
<li>&lt;file-name: get the input from the following file</li>
<li>n &lt;&amp; m : merges input from stream n with stream m</li>
<li>n &gt;&amp; m : merges output from stream n with stream m</li>
<li>!### : execute command number from shell history</li>
<li>!command-prefix : search for and execute the last command starting with the prefix from .bash_history</li>
<li>!! : repeat the last command</li>
<li>!((partial)-command-name) : run the last occurrence of that command</li>
<li>$0&#x2026;$9 : replaced by arguments to shell file (indicate arguments to be placed in a command); $* : shorthand for all the arguments; these are known as positional parameters</li>
<li>$0 stores the name of the script</li>
<li>$$ gives the process-id of the shell script</li>
<li>$? gives the return value of the last command</li>
<li>$! gives the process-id of the last command started in the background with &amp;</li>
<li># : comment out rest of a line</li>
<li>&rsquo; &rsquo; : prevent the shell from interpretted characters as metacharacters; cause shell to interpret input as a single word (does not interpret delimiters)</li>
<li>&ldquo; &rdquo; : prevent the shell from interpretted characters as metacharacters, except that the shell scans the inside of the quotes to look for #, &rsquo;&#x2026;&rsquo;, and \</li>
<li>`path-to-command-name` OR $(command-name): enclose the invocation of a command into the shell</li>
<li>\ : prevent the shell from interpretted characters as metacharacters</li>
<li>( ) : group concatenate commands into a single stream; run commands in a sub-shell</li>
<li>{ } : run commands in current shell</li>
<li>Arrow keys (↑ and ↓) navigate to previous commands in .bash_history</li>
<li>. : present working directory; ./program-name will run the program in the directory</li>
<li>.. : parent directory of pwd</li>
<li>~ : home directory</li>
<li>~&lt;username&gt; : another&rsquo;s user&rsquo;s home directory</li>
<li>/ : root directory</li>
<li>&#x2013; : used to precede words that are used as a command&rsquo;s option. Without &#x2013;, the string of characters forming the word could be perceived as a long list of individual-character-options.</li>
</ul>
</div>

<div id="outline-container-unix-control-characters" class="outline-3">
<h3 id="unix-control-characters"><span class="section-number-3">1.1.</span> UNIX Control Characters</h3>
<div class="outline-text-3" id="text-unix-control-characters">
<ul class="org-ul">
<li>ctrl + c = stop command</li>
<li>ctrl + u = kill line</li>
<li>ctrl + d = there is no more input</li>
<li>ctrl + z = suspend the program running on the command line</li>
<li>ctrl + s = pause output</li>
<li>ctrl + q = resume</li>
<li>ctrl + h = backspace</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-UNIX-commands-to-remember" class="outline-2">
<h2 id="UNIX-commands-to-remember"><span class="section-number-2">2.</span> UNIX Commands To Remember</h2>
<div class="outline-text-2" id="text-UNIX-commands-to-remember">
<ul class="org-ul">
<li>find directory-name -name &ldquo;search-name&rdquo; -print : recursively find file-name in directory-name; find is slower than locate since it traverses directory tree instead of a database</li>
<li>find . -name &ldquo;pattern-to-search&rdquo; : finds files matching pattern</li>
<li>find . -name &ldquo;~\$*.docx&rdquo; -delete : deletes all useless files whose names match the pattern created by microsoft word; delete files matching pattern</li>
<li>find ~ -mmin -30 -print : find all files modified in home directory in the last 30 minutes</li>
<li>grep -n expression file-name : global regular expression printer (search files and print line numbers and lines containing search expression); -y: case independent</li>
<li>grep -nr expression file-directory : search the directory recursively for the expression</li>
<li>grep -n &ldquo;first.*last&rdquo; file-name : (search files and print line numbers and lines beginning and ending with the patterns specified)</li>
<li>The syntax for &#x2013;include is identical. Note that the star is escaped with a backslash to prevent it from being expanded by the shell (quoting it, such as &#x2013;include=&ldquo;*.{cpp,h}&rdquo;, would work just as well). Otherwise, if you had any files in the current working directory that matched the pattern, the command line would expand to something like grep pattern -r &#x2013;include=foo.cpp &#x2013;include=bar.h rootdir, which would only search files named foo.cpp and bar.h, which is quite likely not what you wanted.</li>
<li>grep pattern &#x2026;: &#x2026;</li>
<li>script file-name : start new session and record all terminal input and output into filename; ctrl+d / exit to stop recording</li>
<li>whereis command-name : find binary files, source files, and man pages for a command</li>
<li>which command-name : show where command is located</li>
<li>cd - : toggle between two directories</li>
<li>w : show what programs users are running</li>
<li>sort : sort lines within a file (alphabetically by default)</li>
<li>kill -signal PID : send specified signal to PID</li>
<li>printenv : display environment variables</li>
<li>alias alternative-name-to-use=&rsquo;command-name -options&rsquo; : create alias for command</li>
<li>ln path-to-file new-path-to-link-of-the-file : create hard link to file; hard links link to an inode, but symbolic links don&rsquo;t</li>
<li>ln -s file-path-name path-link-to-file : create symbolic link to hard link (file-name)</li>
<li>javac buggy-program-name.java &gt; error-log-for-file-name 2&gt;&amp;1 : send both output and the error messages into a file</li>
<li>command-name 2&gt;file-to-store-errors : send errors to a file</li>
<li>apropos : finds online manual pages for a specified keyword</li>
<li>split file-name : a file into smaller files</li>
<li>wget  &#x2013;recursive  &#x2013;no-clobber  &#x2013;page-requisites  &#x2013;html-extension  &#x2013;convert-links  &#x2013;no-parent  www.website-to-download.domain</li>
<li>curl wttr.in : Display a local weather report in the terminal.</li>
<li>objdump -d program-name : this shows the memory addresses and assembly instructions needed to run everything in the program</li>
<li>scp sourcepath/filename destinationpath:sourcepath/optionalNewFilename : secure copy program for copying files to/from remote machines; use -r to copy directories (recursively)</li>
<li>locate filename : find filenames inside a database of all file-names, which is updated by the system once a day; the database must be generated first</li>
<li>wc : word count; -c: number of bytes; -m: number of characters; -w: number of words; -l: numbers of lines</li>
<li>javac buggy-program-name.java &gt; error-log-for-file-name 2&gt;&amp;1 : send both output and the error messages into a file</li>
<li>command-name 2&gt;file-to-store-errors : send errors to a file
<ul class="org-ul">
<li>&lt;command-with-misaligned-output&gt;  |  column -t
<ul class="org-ul">
<li>The -s argument marks the separator between columns on the input. Here it&rsquo;s the forward slash, because no filename, group ID, user ID, or file mode will ever have a forward slash in it.</li>
<li>The -o argument marks the separator between columns on the output. Here it&rsquo;s │ (a vertical bar from the box drawing characters, surrounded by spaces).</li>
<li>The -t argument makes it display the output as a table. By default, the output of column without -t is each full line packed into columns, which doesn&rsquo;t seem as useful.</li>
</ul></li>
</ul></li>
<li>startx : start GUI if computer only has CLI running.</li>
</ul>
</div>
</div>

<div id="outline-container-command-description-syntax" class="outline-2">
<h2 id="command-description-syntax"><span class="section-number-2">3.</span> Command Description Syntax</h2>
<div class="outline-text-2" id="text-command-description-syntax">
<p>
Built-in usage help and man pages commonly employ a small syntax to describe the valid command form:
</p>
<ul class="org-ul">
<li>Angle Brackets for required parameters: ping &lt;hostname&gt;</li>
<li>Square Brackets for optional parameters: mkdir [-p] &lt;dirname&gt;</li>
<li>Ellipses for repeated items: cp &lt;source1&gt; [source2…] &lt;dest&gt;</li>
<li>Vertical Bars for choice of items: netstat {-t|-u}</li>
</ul>
<p>
Notice that these characters have different meanings than when used directly in the shell. Angle brackets may be omitted when confusing the parameter name with a literal string is not likely.
</p>
</div>
</div>

<div id="outline-container-fundamental-UNIX-commands" class="outline-2">
<h2 id="fundamental-UNIX-commands"><span class="section-number-2">4.</span> Fundamental Unix Commands To Remember</h2>
<div class="outline-text-2" id="text-fundamental-UNIX-commands">
<ul class="org-ul">
<li>ls -lhStuciaFG file-path
<ul class="org-ul">
<li>-l : long information</li>
<li>-h : human-readable file sizes</li>
<li>-S : sort by file size</li>
<li>-t : sort by time</li>
<li>-u : print the last time the file was read or executed</li>
<li>-c : print the last time the inode was changed</li>
<li>-i : list the system&rsquo;s internal name for a file in decimal</li>
<li>-a : list all</li>
<li>-F : label files with symbols</li>
<li>-G : use color coded output (Graphic)</li>
</ul></li>
<li>ls -R file-path : list all files and subdirectories&rsquo; contents</li>
<li>ls -ld directory-name : print information about the directory itself, not its contents</li>
<li>ls -l : list long information of a directory; format: drwsrwxrwx
<ul class="org-ul">
<li>See: <a href="#first-char-of-ls-l">The First Character Of ls -l</a></li>
</ul></li>
<li>basic commands: history; cd; cp; mv; date; cal; uptime; who; whoami; who am i; clear; passwd; top; vim; emacs; sh : summon sub-shell</li>
<li>chsh path-name-to-new-shell-listed-in-/etc/shells: change your default shell</li>
<li>rm file-name : remove the specified (filename / link / directory entry); when the last link to a file disappears, the system&rsquo;s remove the inode and the file itself</li>
<li>rm -rf : remove a directory and all its contents/subdirectories without asking</li>
<li>man command; /[regular expression] : search for information inside man pages</li>
<li>file file-name : view the file&rsquo;s type (makes educated guess about the file type by reading first few hundred of bytes from file)</li>
<li>touch file-name : create an empty file with a name</li>
<li>wc : word count; -c: number of bytes; -m: number of characters; -w: number of words; -l: numbers of lines</li>
<li>w : show what programs users are running</li>
<li>ps -vf : show processes that are currently running, verbosely (with extra information); ps -L, ps -O keyword, ps -O %cpu, ps -hO %mem, ps -f: extra process information</li>
<li>ps –fe | grep $USER : list only your own processes</li>
<li>ps -ef</li>
<li>sleep ## : suspend execution for numbers of seconds listed</li>
<li>time : reports the elapsed time (execution, process, and system times) for a command</li>
<li>more file-name : display the file, but one screenful at a time</li>
<li>less file-name : display the file, but enable page up and down navigation</li>
<li>head file-name : display the first few lines of a file</li>
<li>tail -# : print last lines in a file</li>
<li>tail -f : displays the newest 10 lines of a program (useful for monitoring files being written by running programs)</li>
<li>man -k keyword : search man pages that contain keyword; used for finding programs to do what you want</li>
<li>man -f command : one line summary of command</li>
<li>uname -a : print operating system information</li>
<li>hostname : print the name of the machine that is logged on</li>
<li>host hostname : print the internet address of a machine</li>
<li>ssh : secure encrypted client shell to login to remote machines</li>
<li>ssh-keygen -t : generates a public and private key for secure shell logging into a system without a password</li>
<li>scp sourcepath/filename destinationpath:sourcepath/optionalNewFilename : secure copy program for copying files to/from remote machines; use -r to copy directories (recursively)</li>
<li>script file-name : start new session and record all terminal input and output into filename; ctrl+d / exit to stop recording</li>
<li>grep -n expression file-name: global regular expression printer (search files and print line numbers and lines containing search expression); -y: case independent</li>
<li>grep -n &ldquo;first.*last&rdquo; file-name: (search files and print line numbers and lines beginning and ending with the patterns specified)</li>
<li>grep -nr expression file-directory: search the directory recursively for the expression</li>
<li>locate filename : find filenames inside a database of all file-names, which is updated by the system once a day; the database must be generated first</li>
<li>last -# (user-name) : print last logins of users and ttys
<ul class="org-ul">
<li>sort : sort lines within a file (alphabetically by default)</li>
</ul></li>
<li>mail : send mail to users or email addresses (must be configured); mesg y / mesg n : display messages from other users
<ul class="org-ul">
<li>## : type number corresponding to message that you want to read</li>
<li>d ## : delete the message associated with the number</li>
<li>s : save a message into a file</li>
<li>q : exit out of mail and save all messages (without deleting) into the file mbox in your home directory</li>
<li>mail user-name : write message to user</li>
<li>ctrl-d : send message</li>
<li>R : Reply : reply to a message</li>
</ul></li>
<li>cmp : compare two files (check for similarity)</li>
<li>diff : report all lines that are changed, added, or deleted from one file to the next (specified in arguments)</li>
<li>diff3 : report all lines that are changed, added, or deleted between three files (specified in arguments)</li>
<li>su : switch user (default is super user)</li>
<li>adduser, addgroup &lt;username&gt;: add a user or group to the system</li>
<li>useradd -c &ldquo;FullName&rdquo; username</li>
<li>newgrp : changes the group permissions to another group</li>
<li>passwd : changes the password for the user on the terminal</li>
<li>kill -signal PID : send specified signal to PID</li>
<li>kill PID : send default signal to PID</li>
<li>kill 0 process-id : stop all processes except the login shell</li>
<li>kill -9 process-id : kill commands not responding to the kill command by using the SIGKILL signal</li>
<li>nohup command-name &amp; : continue to run the command if you log out (&ldquo;no hangup&rdquo;); output will be saved in a file called nohup.out</li>
<li>nice command-name &amp; : run the process with a lower than normal priority</li>
<li>whereis command-name : find executable files for a command</li>
<li>which command-name : show where command is located</li>
<li>printenv : display environment variables</li>
<li>tty : print which terminal is being used</li>
<li>pr file-names : print files</li>
<li>at [time] command(s) [ctrl+d] : run the command(s) at the specified time (24-hour 2130 or 12-hour style 930pm)</li>
<li>echo [text-to-be-printed] : print text that is printed; -n: print the text without printing a following newline</li>
<li>ps augwx : print all processes on the system</li>
<li>ps ax : print list of the current set of processes</li>
<li>dd : convert and copy a file, usually raw, unformatted data from tapes.</li>
<li>chfn : change your personal information like phone number, office location, your real name etc.</li>
<li>export variable-name=whatever-you-want-it-to-be : define/redefine a variable; makes defined variables available to all sub-shells</li>
<li>alias alternative-name-to-use=&rsquo;command-name -options&rsquo; : create alias for command</li>
<li>basename file-path-name : print the name of the file without printing its parent directories</li>
<li>basename file-name.extension extension-to-be-removed : remove the extension of a file</li>
<li>test $variable-name = value : test and return a boolean value; often used in conditional statements</li>
<li>test -f : test is a file is a regular file or a directory</li>
<li>test $variable-name -ge number-to-be-compared : compare two numbers and return a boolean value; often used in conditional statements</li>
<li>ls | wc -l : list the number of items in a folder</li>
<li>cal -3 : print the calendar of last month, this month, and next month</li>
<li>curl : transfer a URL</li>
<li>history | tail -20 : print the last 20 commands</li>
<li>timeout ## : run the process, and kill it after ## seconds if it hasn&rsquo;t ended already</li>
<li>&lt;command-with-misaligned-output&gt;  |  column -t
<ul class="org-ul">
<li>The -s argument marks the separator between columns on the input. Here it&rsquo;s the forward slash, because no filename, group ID, user ID, or file mode will ever have a forward slash in it.</li>
<li>The -o argument marks the separator between columns on the output. Here it&rsquo;s │ (a vertical bar from the box drawing characters, surrounded by spaces).</li>
<li>The -t argument makes it display the output as a table. By default, the output of column without -t is each full line packed into columns, which doesn&rsquo;t seem as useful.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-file-system-root-directories" class="outline-2">
<h2 id="file-system-root-directories"><span class="section-number-2">5.</span> Root Directories In The File System</h2>
<div class="outline-text-2" id="text-file-system-root-directories">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">/boot</td>
<td class="org-left">Linux kernel and boot loader</td>
</tr>

<tr>
<td class="org-left">/dev</td>
<td class="org-left">Special device files</td>
</tr>

<tr>
<td class="org-left">/etc</td>
<td class="org-left">System configuration files</td>
</tr>

<tr>
<td class="org-left">/home</td>
<td class="org-left">Home directory files</td>
</tr>

<tr>
<td class="org-left">/lib</td>
<td class="org-left">Library files for programs</td>
</tr>

<tr>
<td class="org-left">/mnt</td>
<td class="org-left">Mounts points for external storage devices</td>
</tr>

<tr>
<td class="org-left">/root</td>
<td class="org-left">Home directory of root user</td>
</tr>

<tr>
<td class="org-left">/sbin</td>
<td class="org-left">System-administration commands</td>
</tr>

<tr>
<td class="org-left">/tmp</td>
<td class="org-left">Temporary directory</td>
</tr>

<tr>
<td class="org-left">/usr</td>
<td class="org-left">Many important programs</td>
</tr>

<tr>
<td class="org-left">/var</td>
<td class="org-left">Various system files, such as logs</td>
</tr>
</tbody>
</table>

<p>
These are the common top-level directories associated with the root directory:
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">/bin</td>
<td class="org-left">binary or executable programs.</td>
</tr>

<tr>
<td class="org-left">/boot</td>
<td class="org-left">It contains all the boot-related information files and folders such as conf, grub, etc.</td>
</tr>

<tr>
<td class="org-left">/cdrom</td>
<td class="org-left">Historical Mount Point for CD-ROMs</td>
</tr>

<tr>
<td class="org-left">/dev</td>
<td class="org-left">It is the location of the device files such as dev/sda1, dev/sda2, etc.</td>
</tr>

<tr>
<td class="org-left">/etc</td>
<td class="org-left">system configuration files.</td>
</tr>

<tr>
<td class="org-left">/home</td>
<td class="org-left">home directory. It is the default current directory.</td>
</tr>

<tr>
<td class="org-left">/lib</td>
<td class="org-left">It contains kernel modules and a shared library.</td>
</tr>

<tr>
<td class="org-left">/lost+found</td>
<td class="org-left">It is used to find recovered bits of corrupted files.</td>
</tr>

<tr>
<td class="org-left">/media</td>
<td class="org-left">It contains subdirectories where removal media devices inserted.</td>
</tr>

<tr>
<td class="org-left">/mnt</td>
<td class="org-left">It contains temporary mount directories for mounting the file system.</td>
</tr>

<tr>
<td class="org-left">/opt</td>
<td class="org-left">optional or third-party software.</td>
</tr>

<tr>
<td class="org-left">/proc</td>
<td class="org-left">It is a virtual and pseudo-file system to contains info about the running processes with a specific process ID or PID.</td>
</tr>

<tr>
<td class="org-left">/root</td>
<td class="org-left">Home directory of root user</td>
</tr>

<tr>
<td class="org-left">/run</td>
<td class="org-left">It stores volatile runtime data.</td>
</tr>

<tr>
<td class="org-left">/sbin</td>
<td class="org-left">binary executable programs for an administrator.</td>
</tr>

<tr>
<td class="org-left">/srv</td>
<td class="org-left">It contains server-specific and server-related files.</td>
</tr>

<tr>
<td class="org-left">/sys</td>
<td class="org-left">It is a virtual filesystem for modern Linux distributions to store and allows modification of the devices connected to the system.</td>
</tr>

<tr>
<td class="org-left">/tmp</td>
<td class="org-left">temporary space, typically cleared on reboot.</td>
</tr>

<tr>
<td class="org-left">/usr</td>
<td class="org-left">User related programs.</td>
</tr>

<tr>
<td class="org-left">/var</td>
<td class="org-left">Various system files, such as logs.</td>
</tr>
</tbody>
</table>
</div>


<div id="outline-container-first-char-of-ls-l" class="outline-3">
<h3 id="first-char-of-ls-l"><span class="section-number-3">5.1.</span> The First Character of ls -l Output</h3>
<div class="outline-text-3" id="text-first-char-of-ls-l">
<p>
In the &rsquo;ls -l&rsquo; output, the first character can be any of these:
</p>
<ul class="org-ul">
<li>d : directory</li>
<li>- : regular file</li>
<li>l : symbolic link</li>
<li>s : Unix domain socket</li>
<li>p : named pipe</li>
<li>c : character device file</li>
<li>b : block device file</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-man-manual-sections" class="outline-2">
<h2 id="man-manual-sections"><span class="section-number-2">6.</span> Man Manual Sections</h2>
<div class="outline-text-2" id="text-man-manual-sections">
<p>
The standard sections of the manual include:
</p>
<ul class="org-ul">
<li>1      User Commands</li>
<li>2      System Calls</li>
<li>3      C Library Functions</li>
<li>4      Devices and Special Files</li>
<li>5      File Formats and Conventions</li>
<li>6      Games et. al.</li>
<li>7      Miscellaneous</li>
<li>8      System Administration tools and Daemons</li>
</ul>
<p>
Distributions customize the manual section to their specifics, which often include additional sections.
</p>
</div>
</div>

<div id="outline-container-file-system-and-secruity-commands" class="outline-2">
<h2 id="file-system-and-secruity-commands"><span class="section-number-2">7.</span> File Systems And Security Commands</h2>
<div class="outline-text-2" id="text-file-system-and-secruity-commands">
<ul class="org-ul">
<li>cd - : toggle between two directories</li>
<li>pushd other-directory-to-switch-to : push the current directory onto the directory stack and switch to the directory stated</li>
<li>popd : pop the top directory on the directory stack and cd to it</li>
<li>od file-name : octal dump (visible representation of all bytes in file); 7-digit numbers indicate next position
<ul class="org-ul">
<li>-c: interpret bytes as characters, -b: show bytes too; -x: hex; -d: decimal</li>
</ul></li>
<li>pwd : print working directory</li>
<li>find directory-name -name &ldquo;search-name&rdquo; -print : recursively find file-name in directory-name; find is slower than locate since it traverses directory tree instead of a database</li>
<li>find . -name &ldquo;pattern-to-search&rdquo; : finds files matching pattern</li>
<li>find . -name &ldquo;~\$*.docx&rdquo; -delete : deletes all useless files whose names match the pattern created by microsoft word; delete files matching pattern</li>
<li>find ~ -mmin -30 -print : find all files modified in home directory in the last 30 minutes</li>
<li>which program-name : locate program file in user&rsquo;s path</li>
<li>du -h : disk usage, tell how much disk space is consumed by the files in a directory, including all its subdirectories; -a: all files, including subdirectories</li>
<li>du -sh directory-name : print total sum usage of a directory</li>
<li>du -a | grep file-name : search for specific files in a directory</li>
<li>ln file-path-name path-link-to-file : create hard link to file; hard links link to an inode, but symbolic links don&rsquo;t</li>
<li>ln -s file-path-name path-link-to-file : create symbolic link to hard link (file-name)</li>
<li>chmod permissions file-names : change permissions on files (change mode); permissions can be specified either as octal numbers or using symbolic descriptions</li>
<li>chmod ### file-names : each single octal digit specifies the rwx for the file owner, group, and other users respectively: 4 for read, 2 for write, and 1 for execute permission</li>
<li>chmod u+/-<i>=rwx g+</i>-<i>=rwx o+</i>-/=rwx file-names :
<ul class="org-ul">
<li>+ turns a permission on,</li>
<li>- turns a permission off for the file owner, group, or other users.</li>
<li>changes for all users if unspecified</li>
</ul></li>
<li>chmod -R ### / +/- rwx directory-name : change the permissions on directory and subdirectories recursively</li>
<li>chown login-id file-name : change ownership; user must have the privelages of the target user. In most cases, only root can transfer file ownership</li>
<li>chown login-id group-id file-name : change ownership of file owner and group</li>
<li>crypt : encrypt files; note that the super-user could change the crypt the algorithm or command</li>
<li>gzip file-names : compresses files in order to save space; the extension .gz is added to files that it compresses</li>
<li>tar -cvf tarball-name.tar directory-to-be-bundled : Tape ARchive; recursively bundle directory into single file, called a tarball; -c: create; -f: choose name to follow</li>
<li>tar -tvf : -t: list table of contents for tarball without extracting (the tar program does preserve metadata while archiving)</li>
<li>tar -xvf tarball-name.tar : -x: extracts files from tarball</li>
<li>tar -czvf tarball-name.tar.gz directory-to-be-bundled : -z: create a tarball that is also compressed by gzip; uses the extension .tar.gz or .tgz by convention</li>
<li>tar -xzvf tarball-name.tar.gz : -xz: extracts files from a compressed tarball</li>
<li>tar -cjvf tarball-name.tar.bz2 directory-to-be-bundled : -j: create a tarball that is compressed by bzip2</li>
<li>tar -xjvf tarball-name.tar.bz2 directory-to-be-bundled : -j: unpack a tarball that was compressed by bzip2</li>
<li>zip -r file-name.zip directory-name : compression and archive tool available on all operating systems; generally not preferred on Linux since it doesn&rsquo;t preserve metadata</li>
<li>unzip directory-name.zip : uncompress zip archive</li>
<li>quota -v : show current disk space usage and limit for a user (if there is one)</li>
<li>df -h : examine the available free space on all mounted disk file systems; -k: display all filesystems including remote ones</li>
<li>lsblk : list all the storage devices (block devices) connected to the system</li>
<li>sudo fdisk partition-name : commandline utility to create, remove, manage, allocate partitions on block device</li>
<li>sudo mkfs -t file-system-type partition-name : make disk file system on block storage device</li>
<li>mount block-storage-device-to-be-mounted filesystem-location-to-be-mounted-on : mount block storage device to the filesystem</li>
<li>umount block-storage-device : disconnect block device from filesystem</li>
<li>pmap PID : Look the memory mapped zones (including shared libraries) of process PID</li>
<li>dhclient -v :</li>
</ul>
</div>
</div>

<div id="outline-container-filters-pipes-and-redirection" class="outline-2">
<h2 id="filters-pipes-and-redirection"><span class="section-number-2">8.</span> Filters, Pipes, And Redirection</h2>
<div class="outline-text-2" id="text-filters-pipes-and-redirection">
<ul class="org-ul">
<li>tee [file-name] : copy standard input directly into standard output (unbuffered) and optionally another file.</li>
<li>uniq &#x2013; report or filter out repeated lines in a file; -c: print line number and a space before every outputted line</li>
<li>tr : transliterates the characters in its input; a-z A-Z: convert lowercase letters to uppercase; A-Z a-z: convert uppercase letters to lowercase letters; A-Za-z: all letters</li>
<li>comm -options file-name-1 file-name-2 : print three columns of output: lines that only occur in file-name-1, lines that only in file-name-2, lines that occurs in both files; -1: suppress column 1; -2: suppress column2; -3 suppress column3; -i: case insensitive comparison</li>
<li>sed &rsquo;list-of-commands&rsquo; file-names : (Stream EDitor) read lines one at a time from the input files, apply commands from the list (placed within single quotes), in order, to each line and write the edited output to the standard output; -n ’/pattern/p’: only explicitly print patterns with the p command
<ul class="org-ul">
<li>sed ’s/$/\n/’ : prints a newline to the end of each line, thus double spacing a file</li>
<li>sed -n ’20,30p’ : print lines 20 through 30</li>
<li>sed ’1,10d’ : delete lines 1 through 10</li>
<li>sed ’1,/^$/d’ : delete up to and including the first blank line</li>
<li>sed ’$d’ : delete last line</li>
</ul></li>
<li>awk &rsquo;program-name&rsquo; file-names : read lines from an input file and divide them into strings of non-blank characters separated by blanks or tabs. Fields ($1, $2, $NF, $0) apply to the lines like columns; -F@: change the delimiter between fields in any single character (@), like a colon, |, or any other character</li>
<li>javac buggy-program-name.java &gt; error-log-for-file-name 2&gt;&amp;1 : send both output and the error messages into a file</li>
<li>command-name 2&gt;file-to-store-errors : send errors to a file</li>
<li>jobs : print all background jobs started from the current shell</li>
<li>fg %# : bring command into the foreground, where # is the job number associated with the command, as listed by the jobs command; often used on processes stopped by ctrl+z
<ul class="org-ul">
<li>Often used to resume suspended Emacs sessions</li>
</ul></li>
<li>bg : put a command in the background</li>
</ul>
</div>
</div>

<div id="outline-container-shell-scripting" class="outline-2">
<h2 id="shell-scripting"><span class="section-number-2">9.</span> Shell Scripting</h2>
<div class="outline-text-2" id="text-shell-scripting">
<ul class="org-ul">
<li>set : display the values of all defined variables</li>
<li>say : speak the following English phrase (MacOS)</li>
<li>open path-to-file : open file with default application</li>
<li>open -a path-to-application path-to-file : open file with the application specified</li>
<li>source file-name : parse file-name</li>
<li>Shell programming comes in two flavors: shell scripts and shell functions.</li>
<li>Shell scripts, once defined, can be executed just like any other executable as long as they are set to executable. To execute any file, just type the pathname to the file.</li>
<li>Shell scripts are executed in subshells.</li>
<li>Shell functions are similar to shell scripts but are defined in the environment. This simply means that they load much faster than shell scripts and can change the current environment.</li>
<li>Shell functions are generally defined in a file and sourced into the environment.</li>
<li>Almost any command line entry can go into a shell script file.</li>
<li>The first line, called the shebang, contains the file path to the command interpreter. Shell scripts can be used with any interpreter, not just shell languages.</li>
<li>For debugging scripts, bash -x scriptname.sh will display the commands as it runs them.</li>
<li># is used to write comments in the code and such. The variable $# gives the number of command line arguments.</li>
<li>The output of any program can be placed in a commandline (or as the right hand side of an assignment) by enclosing invocation in back quotes: ‘cmd‘ or using the preferred syntax $(cmd).</li>
<li>Shell variables are created when assigned. The assignment statement has strict syntax. There must be no spaces around the = sign and assigned value must be a single word, which means it must be quoted if necessary.</li>
<li>Variables defined in the shell can be made available to shell scripts and programs by exporting them to be environment variables.</li>
<li>echo $i\n; printf &ldquo;%02d\n&rdquo; $i;</li>
<li><p>
for loops:
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #a020f0;">for</span> variable<span style="color: #a020f0;"> in</span> list-of-words
<span style="color: #a020f0;">do</span>
    commands
<span style="color: #a020f0;">done</span> <span style="color: #b22222;"># </span><span style="color: #b22222;">denotes the end of a for loop</span>
<span style="color: #a020f0;">for</span> variable<span style="color: #a020f0;"> in</span> list-of-words; <span style="color: #a020f0;">do</span> commands; <span style="color: #a020f0;">done</span>
<span style="color: #a020f0;">for</span> ((<span style="color: #a0522d;">i</span>=<span style="color: #008b8b;">0</span>; i&lt;<span style="color: #008b8b;">10</span>; i++))
    &gt; do
    &gt;   echo $<span style="color: #a0522d;">i</span>
    &gt; done
</pre>
</div></li>
<li><p>
while loops:
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #a020f0;">while</span> command
<span style="color: #a020f0;">do</span>
    commands
<span style="color: #a020f0;">done</span>
<span style="color: #a020f0;">while</span> command; <span style="color: #a020f0;">do</span> commands; <span style="color: #a020f0;">done</span>
</pre>
</div></li>
<li><p>
until loops:
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #a020f0;">until</span> command
<span style="color: #a020f0;">do</span>
    commands
<span style="color: #a020f0;">done</span>
<span style="color: #a020f0;">until</span> command; <span style="color: #a020f0;">do</span> commands; <span style="color: #a020f0;">done</span>
</pre>
</div></li>
<li><p>
if statements:
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #a020f0;">if</span> command <span style="color: #b22222;"># </span><span style="color: #b22222;">Use [ ] brackets to treat the stuff in between as a test without using the test command itself</span>
<span style="color: #a020f0;">then</span>
    commands
<span style="color: #a020f0;">else</span> <span style="color: #b22222;"># </span><span style="color: #b22222;">elif can be used short for else if command, then ...</span>
    commands
<span style="color: #a020f0;">fi</span> <span style="color: #b22222;"># </span><span style="color: #b22222;">denotes the end of an if statement</span>
</pre>
</div></li>
<li><p>
case statements:
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #a020f0;">case</span> word<span style="color: #a020f0;"> in</span> pattern
             pattern) commands;;
                      pattern) commands;;
                      ...
                      <span style="color: #a020f0;">esac</span> <span style="color: #b22222;"># </span><span style="color: #b22222;">case spelled backwards</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-fedora-yum-RPM-commands" class="outline-2">
<h2 id="fedora-yum-RPM-commands"><span class="section-number-2">10.</span> Fedora Yum RPM Commands</h2>
<div class="outline-text-2" id="text-fedora-yum-RPM-commands">
<ul class="org-ul">
<li>sudo yum update</li>
<li>sudo yum group list ; list groups of additional software</li>
<li>sudo yum search package-name</li>
<li>sudo yum provides command-name ; search for package that provides command</li>
<li>sudo yum info package-name</li>
<li>sudo yum install package-name</li>
<li>sudo yum remove package-name</li>
<li>sudo rpm &#x2013;import repository</li>
<li>nproc : find number of processors available on the system</li>
<li>lscpu : find details about the processors</li>
<li>free - h : find the amount of memory on the system in human reable units</li>
<li>ispell file-name : interactive spell checker on a file</li>
<li>spell file-name : print out all the mispelled words in a file of words
<ul class="org-ul">
<li>both spell commands use a dictionary located in /usr/share/dict/words</li>
</ul></li>
<li>watch -n ## program-name-to-be-executed-every-##-seconds : execute a program or command every # seconds</li>
<li>pick list-of-arguments : presents arguments one at a time and awaits for a response to use them or not (great for piping)</li>
</ul>
</div>
</div>

<div id="outline-container-linux-commands-to-be-installed" class="outline-2">
<h2 id="linux-commands-to-be-installed"><span class="section-number-2">11.</span> Special Linux Commands To Be Installed</h2>
<div class="outline-text-2" id="text-linux-commands-to-be-installed">
<ul class="org-ul">
<li>finger : user information lookup program
<ul class="org-ul">
<li>&rsquo;finger&rsquo; reports the same information as &rsquo;who&rsquo; does, but it also looks up the user&rsquo;s real name (if it&rsquo;s in the user password file), tells how long the terminal has been idle. It also cuts the &rsquo;tty&rsquo; from the terminal names.</li>
<li>If the system administrator has entered the information, &rsquo;finger&rsquo; also shows an office phone number, room number, and other information about where the user works.</li>
<li>Some systems, mainly main network machines at universities have set up &rsquo;finger&rsquo; to return user-directory information.</li>
</ul></li>
<li>finger specific-user&rsquo;s-name : only list the information about that user for all the termainals they are logged into
<ul class="org-ul">
<li>.project and .plan list the current project and witty remarks of the user.</li>
</ul></li>
<li>finger specific-user&rsquo;s-name : only list the information about that user for all the termainals they are logged into
<ul class="org-ul">
<li>finger @system-name : list information about nearby system</li>
<li>finger user-name@system-name : list information about individual on nearby system
<ul class="org-ul">
<li>Note: In principle, you can finger any machine on the internet, but in many cases you get &ldquo;connection refused&rdquo; or even no response since they don&rsquo;t have to answer</li>
</ul></li>
</ul></li>
<li>tree directory-name : graphical tree of file system</li>
<li>htop : improved top</li>
<li>bzip2 / xz : improved gzip</li>
<li>ripgrep : improved grep</li>
<li>mutt : mail program with a better interface</li>
<li>apt-fast : faster than apt-get since uses multiple connections simultaneously</li>
<li>g++ file-name : compile program using GNU C++ compiler</li>
<li>gmake file-name :</li>
<li>gmake 2&gt;&amp;1 | less : launch compilation with a pager; useful when there are a lot of error messages</li>
<li>gdb file-name : debug file with GNU debugger</li>
<li>gdb file-name core_file : examine a core dump file generated by program file-name</li>
<li>neofetch : display aesthetic ASCII rendering of system specs. Better than archey.</li>
<li>.zsh : A utility that keeps track of which directories you visit the most, and creates an index to help you switch to those directories faster in the future.</li>
</ul>
</div>

<div id="outline-container-improved-UNIX-utilities" class="outline-3">
<h3 id="improved-UNIX-utilities"><span class="section-number-3">11.1.</span> List Of Improved UNIX Utilities Vs Common Standards</h3>
<div class="outline-text-3" id="text-improved-UNIX-utilities">
<ul class="org-ul">
<li>Doom-Emacs Versus Emacs</li>
<li>NeoVim Versus Vim</li>
<li>Zshell Versus Bash</li>
<li>htop Versus top</li>
<li>ripgrep Versus grep</li>
<li>apt-fast Versus apt-get</li>
<li>bzip2 / xz Versus gzip</li>
<li>qalc - Calculator</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-common-linux-commands-not-listed" class="outline-2">
<h2 id="common-linux-commands-not-listed"><span class="section-number-2">12.</span> Summary Of Common Linux Commands Not Listed Above</h2>
<div class="outline-text-2" id="text-common-linux-commands-not-listed">
<ul class="org-ul">
<li>apropos : finds online manual pages for a specified keyword</li>
<li>batch : executive commands when load permits</li>
<li>calendar : invoke a reminder service</li>
<li>cancel : cancel a request to printer</li>
<li>chgrp : change group ownership of files</li>
<li>compress : compresses files</li>
<li>copy : copy groups of files in directories</li>
<li>cpio : archive and extract files</li>
<li>cron : clock daemon (executes batch and at commands)</li>
<li>crontab : schedule commands at regular intervals</li>
<li>csh : invoke the C shell</li>
<li>csplit : split a file into several files</li>
<li>cu : call up another Unix system</li>
<li>cut : cut selected fields from each line of a file</li>
<li>dircmp : compare two directories</li>
<li>eject : eject the media from a drive</li>
<li>expand : converts all tabs into spaces</li>
<li>expr : evaluate boolean and arithmetic expressions</li>
<li>false : return nonzero (false) exit status</li>
<li>fgrep : &ldquo;fast&rdquo; version of grep</li>
<li>fold : wraps each line of text to fit a specified width</li>
<li>format : format disks and cartridge tapes</li>
<li>fsck : checks and repairs a file system</li>
<li>ftp : transfer files to and from remote systems</li>
<li>groff : format files for printing</li>
<li>groups : prints the list of groups that includes a specified user</li>
<li>id : displays the user and group ID for a specified user name</li>
<li>info : displays online help information about a specified command</li>
<li>insmod : load a kernel module</li>
<li>join : display the join (lines with common field) of two files</li>
<li>ksh : invoke the Korn shell</li>
<li>ldd : displays the shared librasies needed to run a program</li>
<li>line : read a line (shell script usage)</li>
<li>logname : get login name</li>
<li>lp, lpr : send request to printer</li>
<li>lpc : administer printer queues</li>
<li>lprm : remove print jobs from the queue</li>
<li>lpq : report printer status</li>
<li>lsmod : list loaded kernel modules</li>
<li>mesg : grant or deny permission to receive write messages from other users</li>
<li>mknod : build a special file</li>
<li>mkswap : creates a swap space for Linux in a file or a disk partition</li>
<li>mtools : read and write MS-DOS or Windows disks</li>
<li>nl : numbers all nonblank lines in a text file and prints the lines to standard output</li>
<li>paste : merge lines of files</li>
<li>patch : updates a text file using the differences between the original and revised copy of the file</li>
<li>pstat : report system status</li>
<li>pstree : similar to ps, but shows parent-child relationships clearly</li>
<li>reboot : stops system and restarts the computer</li>
<li>recode : translates files to different formats</li>
<li>rlogin : login to remote Unix systems insecurely</li>
<li>setenv : add value to environmental variable (C Shell)</li>
<li>sh : invoke Bourne shell</li>
<li>shutdown : gracefully shut down system (root)</li>
<li>slogin : login to remote unix systems securely</li>
<li>split file-name : a file into smaller files</li>
<li>stty : set options for a terminal</li>
<li>sum : compute checksums and number of blocks for files</li>
<li>swapoff : deactivates a swap space</li>
<li>swapon : activates a swap space</li>
<li>sync : writes a buffered (saved in memory) data to files</li>
<li>tee : create a tee in a pipe</li>
<li>true : returns zero (true) exit status</li>
<li>tset : set terminal modes</li>
<li>tty : report name of terminal</li>
<li>type : shows the type and location of a command</li>
<li>umask : set file-creation mode (permissions) mask</li>
<li>uucp : copy files between two Unix systems</li>
<li>uulog : report on UUCP status</li>
<li>uuname : list UUCP sites known to this site</li>
<li>uudecode : decode to binary after uuencode transmission</li>
<li>uuencode : encode binary file for email transmission</li>
<li>uustat : report status for or cancel UUCP jobs</li>
<li>uupick : receive public files sent via UUTO</li>
<li>uuto : send public files to another Unix system</li>
<li>uux : execute command on remote Unix system</li>
<li>unalias : deletes an abbreviation defined using alias</li>
<li>uncompress : decompresses files compressed with &rsquo;compress&rsquo;</li>
<li>wall : sends a message to all users (root)</li>
<li>wait : await completion of background processes</li>
<li>whatis : similar to the &rsquo;apropos&rsquo; command, but searches for complete words only</li>
<li>which : finds files in the directories listed in the PATH environment variable</li>
<li>who : list who&rsquo;s using the machine</li>
<li>who am i : print just your line of information on the terminal where you typed this command</li>
<li>whoami : print only the name of the user who typed this command</li>
<li>whois : search for user information</li>
<li>rwho : compile list of all the people using all the machines on the local network</li>
<li>write user-name : send message for another user in real-time (presumably for extremely urgent messages)</li>
<li>write user-name terminal-name : send message in real-time to specific terminal used by user (ideally the one with the least idle time, or the terminal name used to send the last &rsquo;write&rsquo; message if messaging back and forth)</li>
<li>talk user-name&lt;@machine-name&gt; &lt;terminal-name&gt; : start a two-way typing conversation with another user (usually other computers)
<ul class="org-ul">
<li>If you want to respond to someone that is trying to talk to you, you must exit to the shell (if you are in the middle of a text editor or other program) and type &rsquo;talk&rsquo; in the shell.</li>
<li>If you want to talk to a number of other people (perhaps thousands of them), you can use Internet Relay Chat (IRC).</li>
</ul></li>
<li>zcat : displays a compressed file (after decompressing)</li>
<li>zless : displays a compressed file one page at a time (can go backward also)</li>
<li>zmore : displays a compressed file one page at a time</li>
</ul>
</div>
</div>

<div id="outline-container-UNIX-notes" class="outline-2">
<h2 id="UNIX-notes"><span class="section-number-2">13.</span> UNIX Notes</h2>
<div class="outline-text-2" id="text-UNIX-notes">
<ul class="org-ul">
<li>Any commands stored in .bash_profile in the user&rsquo;s login directory will be executed when the user logs in, before printing the first prompt.</li>
<li>(UTF = Unicode Transformation Format)</li>
<li>Tty stands for teletype. The rc suffix stands for &ldquo;run control&rdquo;; ex: .vimrc, .bashrc</li>
<li>ed &gt; em &gt; en &gt; ex &gt; vi &gt; vim &gt; gvim</li>
<li>The .bash_profile file in the user&rsquo;s home directory is sourced for each interactive login session, while .bashrc is sourced for all interactive sessions. There are many ways to customize it.
<ul class="org-ul">
<li>export variable-name=&ldquo;&rdquo; : assigns a value to variables</li>
<li>set -o vi : set the editor mode to vim
<ul class="org-ul">
<li>/string : search for previous commands in .bash_history</li>
</ul></li>
<li>alias command-alias-name=&rsquo;unix-command -option&rsquo;</li>
</ul></li>
<li>man bash shows all the shell parameters, variables, and just about all the information there is to know about how to use the shell.</li>
<li>sd stands for scsi disk. sda is the first drive, sdb the second, sdc the third, and so on. The number that follows is the partition number on the drive.</li>
<li>In Linux, all applications are stored under /usr/share/applications.</li>
<li>u = single user; g = group of users; o = other users</li>
<li>stdin = standard input, stdout = standard output, stderr = standard error; the corresponding file streams are each numbered 0, 1, and 2 respectively.</li>
<li>Variables can be defined in your .profile. These could be things such as a long directory path that you constantly refer to.</li>
<li>Shell variables are usually in all caps and user-defined variables are conventionally all lower-case to distinguish the two.</li>
<li>The value of any shell variable can be obtained by prefixing the variable with $. echo $SHELL_VARIABLE can output the current value of the variable.
<ul class="org-ul">
<li>$PS1 is the shell variable responsible for the prompt string (usually $). One can set it with syntax: PS1=&rsquo;whatever you want&rsquo;</li>
<li>$PATH is the shell variable that controls the search path where the shell looks for commands.</li>
<li>TERM names the kind of terminal you are using.</li>
<li>( set -o posix ; set ) | less : list all shell variables and environment variables.</li>
</ul></li>
<li>RETURN/ENTER is interpretted by the kernel as both a carriage return and a newline, but only stores the newline / linefeed in the input.</li>
<li>Programs retrieve the data in a file by a system call called read. Each time read is called, it returns the next part of a file.</li>
<li>Input lines are not returned to the kernel until you type newline. Once newline is entered, no changes can be made because it was already read by the system.</li>
<li>Every running program (every process) has a current directory and all filenames are implicitly assumed to start with the name of that directory, unless specified otherwise.</li>
<li>Files themselves never determine what programs do with them. All files are just data, and programs determine what they do with files.</li>
<li>Files that have the same function are only the same because a set of commonly agreed standards determined that they all follow a set of conventions and have similar formatting.</li>
<li>The purpose of a file extension is thus not to determine how a file works, but to determine what programs will open a file.</li>
<li>When users enter in their passwords the passwords go through the encryption algorithm so that the system can compare it with the password on the system, which is also encrypted.</li>
<li>It&rsquo;s easy to go from the clear form to the encrypted form, but very hard to go backwards.</li>
<li>People have login directories as their attributes, processes have current directories as their attributes.</li>
<li>Even though directories sit in the file system as ordinary files, only the kernel has the ability to control the contents of the directories.</li>
<li>Default search path: System first checks current directory, then /bin, then /usr/bin for program names that match the prompt input.</li>
<li>The super-user can read and write ANY file on the system.</li>
<li>The username that one uses to login is the login-id, but the number that the system recognizes users by is actually the user-id, or uid.</li>
<li>The group-id is the group identification. The information for group names, group-id&rsquo;s, and which users are in which groups are stored in /etc/group.</li>
<li>/etc/passwd only identifies the the login group.</li>
<li>A program is just a file that has execute permission.</li>
<li>One cannot simply write in a directory (though one can create and delete files in a directory), even root is forbidden from doing so. Only system calls can write to directories.</li>
<li>Permission to remove a file is independent of the file itself, even for files that are protected against writing. A directory&rsquo;s write permissions determine this.</li>
<li>Files cannot be removed unless the user has write privelages for the directory where the file is located.</li>
<li>Only a file&rsquo;s owner and the super-user may be able to change the permissions of a file, regardless of the permissions themselves.</li>
<li>The x field for permissions on a directory mean &ldquo;search&rdquo; instead of execution, which determine if a directory can be searched for a file.
<ul class="org-ul">
<li>Thus, directories can be created that allow users to access files that they know are in the directory, while preventing them from reading what files are in the directory.</li>
</ul></li>
<li>The inodes (originally i-nodes and index-nodes) identifies the permissions and dates for the files; The three times/dates in the inode are: the time when the contents of the file were last modified (written), the time that the file was last used (read or executed), and the time that the inode itself was last changed.</li>
<li>In the context of Unix file systems, “metadata” is information about a file: who owns it, permissions, file type (special, regular, named pipe, etc) and which disk-blocks the file uses, which is all typically contained in the inodes in the on-disk structure.</li>
<li>The usage time for a file reported by ls -lu reports when the file was last used, not when it was last written to.</li>
<li>Changing permissions only affects the inode change time, as reported by ls -lc.</li>
<li>All the directory hiearchy does is provide convenient names for files. The system&rsquo;s internal name for a file is its i-number: the number of the inode holding the file&rsquo;s info.</li>
<li>When a directory entry is zero (see od -d), then the link has been removed, but not the contents of the file as long as there is still another link in the filesystem.</li>
<li>/dev is where devices get connected to the filesystem and unix system. Inside the kernel, references to that file are converted into hardware commands to access devices.</li>
<li>Links can be anywhere as long as they&rsquo;re not between two subsystems, since they can unmounted, don&rsquo;t have unique inodes between systems, and have limits on file size and inodes.</li>
<li>Hard links cannot be made to directories, but soft symbolic links can.</li>
<li>Hard links link directly the inodes. Every file has at least one hard link. Symbolic links can only link to a hard link. If the hard link that the symbolic link is linked to is deleted, then the symbolic link will be left dangling and pointing to no object.</li>
<li>When a disk space quota is exceeded, the system grants the user seven days to remove or compress files until they are below the quota, or else it will suspend login priveleges.</li>
<li>Only the user can read from or write to their terminal. The device /dev/tty# is a synonym for the login terminal.</li>
<li>In one context, file system refers to the directory hierarchy that a user interacts with when using command line tools or browsing for a file. However, file system also refers to the software layer that manages how files are stored and retrieved from physical storage devices such as hard disk drives, USB thumb drives, solid state drives, etc.</li>
<li>Linux supports a large number of file systems, each with their own pros and cons. The various disk file systems try to balance read performance, write performance, large file performance, small file performance, reliability, and recoverability. There is not a perfect solution, which is why there are so many options. The xfs disk file system is the default for CentOS while ext4 is the default for Ubuntu and Fedora Linux. Both provide a good balance for workloads typically associated with a development workstation.</li>
<li>/etc/fstab is the file system table that determines which storage devices are automatically mounted at boot.</li>
<li>Ctrl + C sends SIGNINT / TERM signal to a command. Ctrl + Z sends the STOP signal to a command.</li>
<li>The AWK Programming Language by Alfred V. Aho, Brian W. Kernighan, Peter J. Weinberger, Addison Wesley.</li>
<li>awk is based on the C Programming Language and it can implement arrays, loops, if-statements, and other full programming language statements based on C. An entire book has been written on it and it is a stand-alone programming language specialized for text-processing.</li>
<li>There are three data streams associated with every command ran under Linux: stdin, stdout, and stderr (standard input, standard output, and standard error). The corresponding file numbers for all of these are 0, 1, and 2; 2&gt;: redirect error messages from stderr to stdout</li>
<li>File matching characters do not look at filenames beginning with a dot unless explicitly specified.</li>
<li>Single quotes protect double quotes and double quotes protect single quotes inside the shell.</li>
<li>In shell terminology, a word is defined as any single string that a shell accepts as a unit, including blanks if they are quoted.</li>
<li>&rsquo;&gt; &rsquo; is a secondary prompt printed by the shell when it expects the user to type more input to complete a command.</li>
<li>A backslash at the end of a line causes the input to be continued below the line. Newlines are discarded when preceded by a backslash, but retained when in quotes.</li>
<li>The value of a variable is associated with the shell that creates it, and is not automatically passed to the shell&rsquo;s sub-shells unless the export command is used.</li>
<li>Every program has three default files established when it starts, numbered by three file descriptors: 0,1,2 (stdin, stdout, stderr); 1&gt;&amp;2 can add stdout to stderr.</li>
<li>The grep family of programs supports character classes. Since egrep is faster and can search for more general expressions that the original grep, they got combined into a single pattern matching program is some Unix distributions.</li>
<li>In Vim, :%s/  OR  /  + up-down-arrows can enable one to search using past strings</li>
<li>How Most Linux Package Managers Work: 1. Download .rpm/.pkg/&#x2026; file. The package manager will: 1. unpack the file (decompress &amp; extract the files), 2. put the resulting little files in their correct places, and 3. update a database of installed software on the computer.
<ul class="org-ul">
<li>If you later want to install an upgrade, the package manager remembers an older version is already installed and saves any existing configuration files while upgrading the necessary files.</li>
<li>You can only install software using a package manager if you are the system administrator.</li>
</ul></li>
<li>Shar (shell archive) messages are a way to send messages to other users. First you save the message in a separate file, delete all the lines at the beginning of the file until the first line that starts with #, and feed the saved file into a shell with the syntax:  sh shar-file-to-be-read
<ul class="org-ul">
<li>The command will run the script in the file and create the program files or whatever else is in the shar file. Then you delete the saved shar file since it&rsquo;s not needed anymore, and move the created files to the appropriate place, probably to the your bin directory.</li>
</ul></li>
<li>To install programs from uuencode files (typically binary programs), save the uuencode message into a file, and feed the uuedecode program with the line:  uudecode uu-file-to-read
<ul class="org-ul">
<li>The command will run the script in the file and create the program files or whatever else is in the uuencode file. Then you delete the saved uuencode file since it&rsquo;s not needed anymore, and move the created files to the appropriate place, probably to the your bin directory.</li>
</ul></li>
<li>UNIX was designed as a multi-user system from the very beginning, in part because it was very expensive to buy a computer back then for only one person.</li>
<li>Computers use all kinds of protocols to communicate.
<ul class="org-ul">
<li>On a network, clients connect to servers by using protocols such as TCP/IP (Transmission Control Protocol / Internet Protocol) and IPX (Internetwork Packet eXchange).</li>
<li>Computers connected by the Internet exchange files by using protocols such as FTP (File Transfer Protocol) and HTTP (HyperText Transfer Protocol).</li>
<li>SMB is a protocol included in all versions of Windows that enables communication between UNIX and Windows computers.
<ul class="org-ul">
<li>Samba is a suite of programs who can turn any version of UNIX into an SMB server.</li>
<li>SMB is a request-response protocol, in which a client makes requests of the server, and the server responds. A client usually has to make several requests to a server before anything useful happens, including which dialect of SMB it wants to speak, and a username and password. If the server accepts, the client can petition the server with a series of requests - for example: to locate, open, and print a particular file.</li>
</ul></li>
</ul></li>
<li>The whereis command shows you the location for the binary, source, and man pages for a command, whereas the which command only shows you the location of the binary for the command.</li>
<li>When the internet was first starting, people used their phone lines to connect to the internet?</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Last Modified: 2024 May 17, 10:36</p><p class="author">Author: Zero Contradictions</p>
</div>
</body>
</html>
